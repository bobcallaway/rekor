//
// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package dev.sigstore.rekor;

import "google/api/annotations.proto";
import "google/api/client.proto";
import "google/api/field_behavior.proto";
import "pkg/types/types.proto";

option go_package = "github.com/sigstore/rekor/pkg/generated/protobuf";
option java_package = "dev.sigstore.rekor";
option java_multiple_files = true;
option java_outer_classname = "RekorEntriesProto";

service Entries {
    /**
     * Creates an entry in the transparency log for an artifact.
     */
    rpc CreateLogEntry(CreateLogEntryRequest) returns (LogEntry){
        option (google.api.http) = {
          post: "/api/v2/log/entries"
          body: "*"
        };
        option (google.api.method_signature) = "log_entry";
    }
    /**
     * Retrieves an entry and inclusion proof from the transparency log (if it exists)
     */
    rpc GetLogEntry(GetLogEntryRequest) returns (LogEntry){
        option (google.api.http) = {
          get: "/api/v2/log/entries/{uuid}"
          additional_bindings: {
              get: "/api/v2/log/entries"
          }
        };
    }
    /**
     * Returns a list of (optionally filtered) entries from the transparency log
     */
    rpc ListLogEntries(ListLogEntriesRequest) returns (ListLogEntriesResponse){
        option (google.api.http) = {
          get: "/api/v2/log/entries/retrieve"
        };
    }
}

/*
 * Represents a proposed log entry; Rekor will verify the validity of the digital signature contained within
 * before committing the entry into the log
 */
message CreateLogEntryRequest {
    /*
     * The proposed entry to be made into the log
     */
    dev.sigstore.rekor.types.ProposedLogEntry proposed_entry = 1 [(google.api.field_behavior) = REQUIRED];
}

/*
 * Represents an envelope that contains both a log entry as well as the material required to prove inclusion
 * in the transparency log
 */
message LogEntry {
    /*
     * The log entry object
     */
    LogEntryObject entry      = 1;
    /*
     * Contains information that can be used to prove the inclusion of the entry into the transparency log
     * along with a digital signature over the log entry content
     */
    Verification verification = 2;
}

/*
 * Represents a log entry (with relevant metadata) that has been written to the log
 */
message LogEntryObject {
    /*
     * The log ID, which is computed as the SHA256 digest of the DER-encoded public key of the log
     */
    string log_id                               = 1;
    /*
     * The index of the entry within the log
     */
    int64 log_index                             = 2;
    /*
     * The fields of the entry
     */
    dev.sigstore.rekor.types.TypedEntry body = 3;
    /*
     * The time that the entry was integrated into the transparency log
     */
    int64 integration_time                      = 4;
    /*
     * The attestation provided at the time of insertion (if present)
     */
    Attestation attestation                     = 5;
}

/*
 * Represents an attestation related to a particular log entry
 */
message Attestation {
    /*
     * The attestation content
     */
    bytes payload = 1;
}

/*
 * Verification contains both an inclusion proof for the entry within the log, as
 * well as a digitally signed 
 */
message Verification {
    /*
     * The proof that the entry exists in the transparency log
     */
    InclusionProof inclusion_proof = 1;
    /*
     * A digital signature over the RFC8785 canonicalized JSON version of LogEntryObject
     */
    bytes signed_entry_timestamp   = 2;
}

/*
 * Inclusion proof includes the entire set of information required to compute a proof
 * of inclusion for an entry in an RFC6962-defined Merkle tree
 */
message InclusionProof {
    /*
     * The index of the entry within the log
     */
    int64 log_index        = 1;
    /*
     * The hash value stored at the root of the merkle tree at the time the proof was generated
     */
    string root_hash       = 2;
    /*
     * The current number of nodes in the merkle tree
     */
    int64 tree_size        = 3;
    /*
     * One or more hash values that can be combined to calculate an inclusion proof
     */
    repeated string hashes = 4;
}

/*
 * Represents a request to fetch an entry from the transparency log
 */
message GetLogEntryRequest {
    /*
     * The universally unique identifier for the entry within the log shard
     */
    string uuid     = 1;
    /*
     * The index of the entry within the log
     */
    int64 log_index = 2;
}

/*
 * Represents a request to find all matching entries from within the transparency log
 */
message ListLogEntriesRequest {
    /*
     * A list of candidate entries to search for
     */
    repeated dev.sigstore.rekor.types.ProposedLogEntry proposed_entries = 1;
    /*
     * A list of UUIDs to search for
     */
    repeated string uuids                                               = 2;
    /*
     * A list of log indices to search for
     */
    repeated int64 log_indices                                          = 3;
}

/*
 * Represents a response of all matching entries from within the transparency log
 */
message ListLogEntriesResponse {
    /*
     * A list of entries found in the log
     */
    repeated LogEntry log_entries = 1;
}