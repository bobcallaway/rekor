//
// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package dev.sigstore.rekor.v2;

import "google/api/annotations.proto";
import "google/api/client.proto";
import "google/api/field_behavior.proto";
import "pkg/types/types.proto";

option go_package = "github.com/sigstore/rekor/pkg/generated/protobuf";
option java_package = "dev.sigstore.rekor.v2";
option java_multiple_files = true;
option java_outer_classname = "RekorEntriesProto";

service Entries {
    /**
     * Creates an entry in the transparency log for an artifact.
     */
    rpc CreateLogEntry(CreateLogEntryRequest) returns (LogEntry){
        option (google.api.http) = {
          post: "/api/v2/log/entries"
          body: "*"
        };
        option (google.api.method_signature) = "log_entry";
    }
    /**
     * Retrieves an entry and inclusion proof from the transparency log (if it exists)
     */
    rpc GetLogEntry(GetLogEntryRequest) returns (LogEntry){
        option (google.api.http) = {
          get: "/api/v2/log/entries/{uuid}"
          additional_bindings: {
              get: "/api/v2/log/entries"
          }
        };
    }
    /**
     * Returns a list of (optionally filtered) entries from the transparency log
     */
    rpc ListLogEntries(ListLogEntriesRequest) returns (ListLogEntriesResponse){
        option (google.api.http) = {
          get: "/api/v2/log/entries/retrieve"
        };
    }
}

message CreateLogEntryRequest {
    /*
     * The proposed entry to be made into the log
     */
    dev.sigstore.rekor.v2.types.ProposedLogEntry proposed_entry = 1 [(google.api.field_behavior) = REQUIRED];
}

message LogEntry {
    /*
     * The log ID, which is computed as the SHA256 digest of the DER-encoded public key of the log
     */
    string log_id                               = 1;
    /*
     * The index of the entry within the log
     */
    int64 log_index                             = 2;
    /*
     * The fields of the entry
     */
    dev.sigstore.rekor.v2.types.TypedEntry body = 3;
    /*
     * The time that the entry was integrated into the transparency log
     */
    int64 integration_time                      = 4;
    /*
     * The attestation provided at the time of insertion (if present)
     */
    Attestation attestation                     = 5;
    /*
     * The proof that the entry exists in the transparency log
     */
    Verification verification                   = 6;
}

message Attestation {
    /*
     * The attestation content
     */
    bytes payload = 1;
}

message Verification {
    /*
     * The proof that the entry exists in the transparency log
     */
    InclusionProof inclusion_proof = 1;
    /*
     * The proof that the entry exists in the transparency log
     */
    bytes signed_entry_timestamp   = 2;
}

message InclusionProof {
    /*
     * The index of the entry within the log
     */
    int64 log_index        = 1;
    /*
     * The hash value stored at the root of the merkle tree at the time the proof was generated
     */
    string root_hash       = 2;
    /*
     * The current number of nodes in the merkle tree
     */
    int64 tree_size        = 3;
    /*
     * One or more hash values that can be combined to calculate an inclusion proof
     */
    repeated string hashes = 4;
}

message GetLogEntryRequest {
    /*
     * The universally unique identifier for the entry within the log shard
     */
    string uuid     = 1;
    /*
     * The index of the entry within the log
     */
    int64 log_index = 2;
}

message ListLogEntriesRequest {
    /*
     * A list of candidate entries to search for
     */
    repeated dev.sigstore.rekor.v2.types.ProposedLogEntry proposed_entries = 1;
    /*
     * A list of UUIDs to search for
     */
    repeated string uuids                                                  = 2;
    /*
     * A list of log indices to search for
     */
    repeated int64 log_indices                                             = 3;
}

message ListLogEntriesResponse {
    /*
     * A list of entries found in the log
     */
    repeated LogEntry log_entries = 1;
}