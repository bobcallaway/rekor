//
// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package dev.sigstore.rekor.v2;

import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/empty.proto";

option go_package = "github.com/sigstore/rekor/pkg/generated/protobuf";
option java_package = "dev.sigstore.rekor.v2";
option java_multiple_files = true;
option java_outer_classname = "RekorLogProto";

service Log {
    /**
     * Returns information about the current state of the transparency log
     */
    rpc GetLogInfo(google.protobuf.Empty) returns (LogInfo){
        option (google.api.http) = {
          get: "/api/v2/log"
        };
    }
    /**
     * Returns the public key that can be used to validate the signed tree head
     */
    rpc GetLogPublicKey(GetLogPublicKeyRequest) returns (LogPublicKey){
        option (google.api.http) = {
          post: "/api/v2/log/publicKey"
        };
    }
    /**
     * Returns a consistency proof for the log between two points
     */
    rpc GetConsistencyProof(GetConsistencyProofRequest) returns (ConsistencyProof){
        option (google.api.http) = {
          post: "/api/v2/log/proof"
        };
    }
}

message LogInfo {
    /*
     * The information about the currently active shard
     */
    LogShardInfo current_shard_info           = 1;
    /*
     * The information about inactive (previous) shards
     */
    repeated LogShardInfo inactive_shard_info = 2;
}

message TreeID {
    /*
     * The ID of the tree
     */
    int64 id = 1;
}

message LogShardInfo {
    /*
     * The current hash value stored at the root of the merkle tree
     */
    string root_hash       = 1;
    /*
     * The current number of nodes in the merkle tree
     */
    int64 tree_size        = 2;
    /*
     * The current signed tree head
     */
    bytes signed_tree_head = 3;
    /*
     * The tree ID
     */
    TreeID tree_id         = 4;
}

message GetLogPublicKeyRequest {
    /*
     * The ID of the tree you wish to get a public key for
     */
    TreeID tree_id = 1 [(google.api.field_behavior) = REQUIRED]; 
}

message LogPublicKey {
    /*
     * PEM encoded public key
     */
    string content = 1;
}

message GetConsistencyProofRequest {
    /*
     * The ID of the tree you wish to get a consistency proof for
     * (defaults to the current tree if not specified)
     */
    TreeID tree_id   = 1;
    /*
     * The size of the tree that you wish to prove consistency from
     * (1 means the beginning of the log)
     */
    int64 start_size = 2; // TODO: set minimum and default to 1
    /*
     * The size of the tree that you wish to prove consistency to
     * (defaults to the current size of the tree)
     */
    int64 end_size   = 3 [(google.api.field_behavior) = REQUIRED]; // TODO: set minimum
}

message ConsistencyProof {
    /*
     * The hash value stored at the root of the merkle tree at the time the proof was generated
     */
    string root_hash       = 1;
    /*
     * One or more hash values that can be combined to calculate a consistency proof
     */
    repeated string hashes = 2;
}
